multiline
<drac2>

def validate_dice_notation(input_string: str):

    if not typeof(input_string) == "str":
        return False


    else:

        parts = input_string.split("d")

        if len(parts) != 2:
            return False

        elif not (parts[0].lstrip("-").isdigit()):

            if parts[0] == "":
                parts[0] = "1"

                if not parts[1].isdigit():
                    return False

                else:
                    return True

            else:
                return False

        elif not parts[1].isdigit():
            return False

        else:
            return True
    




def validate_svar_dict(svar_dict: dict, error_list: list[str]):

    for setting in svar_dict["Settings"].keys():

        match setting:

            case c if c in ["water", "wind", "temp"]:

                for inner_setting, inner_value in svar_dict["Settings"][setting].items():

                    if "min_rate" in inner_value.keys():
                        if not "max_rate" in inner_value.keys():
                            error_list.append(f"General setting {setting} in {inner_setting} is missing a max_rate, min_rate has been removed")
                            svar_dict["Settings"][setting][inner_setting].pop("min_rate")

                    if "max_rate" in inner_value.keys():
                        if not "min_rate" in inner_value.keys():
                            error_list.append(f"General setting {setting} in {inner_setting} has min_rate defaulted to 0")
                            svar_dict["Settings"][setting][inner_setting]["min_rate"] = 0

            case c if c == "unit":

                svar_dict["Settings"][setting] = svar_dict["Settings"][setting].lower()

                if not svar_dict["Settings"][setting] in ["metric", "imperial"]:
                    error_list(f"General setting unit has an invalid input (`{svar_dict["Settings"][setting]}`) defaulted to imperial")
                    svar_dict["Settings"][setting] = "imperial"

            case c if c == "url":
                invalid_season_list = []

                for inner_setting, inner_value in svar_dict["Settings"][setting].items():

                    if typeof(inner_value) == "str":

                        if not inner_value.lower().endswith([".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp"]):
                            invalid_season_list.append(inner_setting)

                            error_list.append(f"General setting url has an invalid input (`{inner_value}`).\nRemoving image from season.")

                        if not inner_value.lower().startswith("http")
                            invalid_season_list.append(inner_setting)

                            error_list.append(f"General setting url has an invalid input (`{inner_value}`).\nRemoving image from season.")

                    else:
                        invalid_season_list.append(inner_setting)

                        error_list.append(f"General setting url has an invalid input (`{inner_value}`).\nRemoving image from season.")       

                for invalid_season in invalid_season_list:
                    svar_dict["Settings"][setting].pop(invalid_season)

            case c if c == "color":
                invalid_color_dict = {}
                update_color_dict = {}

                for inner_setting, inner_value in svar_dict["Settings"][setting].items():

                    if typeof(inner_value) == "SafeList":

                        for color_hex in inner_value:

                            if typeof(color_hex) == "str":
                                error = False

                                color = color_hex.lstrip("#").upper()

                                if len(color) == 3:
                                    color = "".join([char * 2 for char in color])

                                elif len(color) == 6:
                                    pass


                                else:
                                    if inner_setting in invalid_color_dict.keys():
                                        invalid_color_dict[inner_setting].append(color_hex)

                                    else:
                                        invalid_color_dict[inner_setting] = [color_hex]

                                    error_list.append(f"General setting color, {inner_setting} has an invalid input (`{color_hex}`).\nRemoving color from season.")

                                    error = True

                                if not error:
                                    if all(c in "0123456789ABCDEF" for c in color):
                                        
                                        if inner_setting in update_color_dict.keys():
                                            update_color_dict["inner_setting"].append([color_hex, color])

                                        else:
                                            update_color_dict["inner_setting"] = [[color_hex, color]]

                                    else:
                                        if inner_setting in invalid_color_dict.keys():
                                            invalid_color_dict[inner_setting].append(color_hex)

                                        else:
                                            invalid_color_dict[inner_setting] = [color_hex]

                                        error_list.append(f"General setting color, {inner_setting} has an invalid input (`{color_hex}`).\nRemoving color from season.")

                for season, color_hex in invalid_color_dict.items():

                    svar_dict["Settings"][setting][season].remove(color_hex)

                for season, color_hex_pair in update_color_dict:
                    svar_dict["Settings"][setting][season].remove(color_hex_pair[0])
                    svar_dict["Settings"][setting][season].append(color_hex_pair[1])

    for location in svar_dict.keys():

        if location != "Settings":

            if not "priority" in svar_dict[location].keys():
                error_list.append(f"{location} settings, priority missing. Setting default value (`999`)")

                svar_dict[location]["priority"] = 999

            else:
                if typeof(svar_dict[location]["priority"]) != "int":
                error_list.append(f"{location} settings, priority invalid input. Setting default value (`999`)")

                svar_dict[location]["priority"] = 999


            for season in svar_dict[location].keys():

                if season != "priority":

                    if not "temp_dice" in svar_dict[location][season].keys():
                        error_list.append(f"{location} settings, season {season} temp_dice missing. Setting default value (`2d10`)")

                        svar_dict[location][season]["temp_dice"] = "2d10"

                    else:

                        if not validate_dice_notation(svar_dict[location][season]["temp_dice"]):
                            error_list.append(f"{location} settings, season {season} temp_dice invalid input. Setting default value (`2d10`)")

                            svar_dict[location][season]["temp_dice"] = "2d10"


                    if not "temp_base" in svar_dict[location][season].keys():
                        error_list.append(f"{location} settings, season {season} temp_base missing. Setting default value (`32`)")

                        svar_dict[location][season]["temp_base"] = 32

                    else:

                        try:
                            svar_dict[location][season]["temp_base"] = int(svar_dict[location][season]["temp_base"])

                        except:

                            error_list.append(f"{location} settings, temp_base missing. Setting default value (`32`)")

                            svar_dict[location][season]["temp_base"] = 32

                    if not "water_dice" in svar_dict[location][season].keys():
                        error_list.append(f"{location} settings, season {season} water_dice missing. Setting default value (`1d20`)")

                        svar_dict[location][season]["water_dice"] = "1d20"

                    else:

                        if not validate_dice_notation(svar_dict[location][season]["water_dice"]):
                            error_list.append(f"{location} settings, season {season} water_dice invalid input. Setting default value (`1d20`)")

                            svar_dict[location][season]["water_dice"] = "1d20"

                    if not "water_conditions" in svar_dict[location][season].keys():
                        error_list.append(f"{location} settings, season {season} water_conditions missing. Setting default value (`'1': 'Clear'`)")

                        svar_dict[location][season]["water_conditions"] = {"1": "Clear"}

                    else:
                        temp_list = []

                        for integer, condition in svar_dict[location][season]["water_conditions"].items():

                            try:
                                int(integer)

                                if not typeof(condition) == "str":
                                    assert False


                                if not condition in svar_dict["Settings"]["water"].keys():
                                    error_list.append(f"{location} settings, season {season} water_condition warning. {condition} does not exist in General Water Settings")

                            except:
                                temp_list.append(integer)
                                error_list.append(f"{location} settings, season {season} water_condition error. Removing value (`{integer}:{condition}`)")

                        for integer in temp_list:
                            svar_dict[location][season]["water_conditions"].pop(integer)

                    if not "wind_dice" in svar_dict[location][season].keys():
                        error_list.append(f"{location} settings, season {season} wind_dice missing. Setting default value (`1d20`)")

                        svar_dict[location][season]["wind_dice"] = "1d20"

                    else:

                        if not validate_dice_notation(svar_dict[location][season]["wind_dice"]):
                            error_list.append(f"{location} settings, season {season} wind_dice invalid input. Setting default value (`1d20`)")

                            svar_dict[location][season]["wind_dice"] = "1d20"

                    if not "wind_conditions" in svar_dict[location][season].keys():
                        error_list.append(f"{location} settings, season {season} wind_conditions missing. Setting default value (`'1': 'None'`)")

                        svar_dict[location][season]["wind_conditions"] = {"1": "None"}

                    else:
                        temp_list = []

                        for integer, condition in svar_dict[location][season]["wind_conditions"].items():

                            try:
                                int(integer)

                                if not typeof(condition) == "str":
                                    assert false


                                if not condition in svar_dict["Settings"]["wind"].keys():
                                    error_list.append(f"{location} settings, season {season} wind_condition warning. {condition} does not exist in General Wind Settings")

                            except:
                                temp_list.append(integer)
                                error_list.append(f"{location} settings, season {season} wind_condition error. Removing value (`{integer}:{condition}`)")

                        for integer in temp_list:
                            svar_dict[location][season]["wind_conditions"].pop(integer)

    return svar_dict, error_list

                            

                    

                    


            

                            

        








# Cycle through the SVAR and validate it, removing any items that it has problems with 

# (start at removing season -> location) for locations
# (start at removing specific condition -> measurement)


def edit_general_settings(dict_input: dict, svar_dict: dict):

    error_list = []

    # Grabbing water, wind, etc.
    for outer_key, outer_value in dict_input.items():

        if outer_key in ["water", "wind", "temp", "unit", "url", "color"]
            svar_dict["Settings"][outer_key] = outer_value

        else:
            error_list.append(f"{outer_key} is not a valid setting for general settings.")


    return validate_svar_dict(svar_dict, error_list)

def edit_location_settings(dict_input: dict, svar_dict: dict):

    error_list = []

    # Location, location dict
    for outer_key, outer_value in dict_input.items():

        # If priority is not in location dict
        if not "priority" in outer_value.keys():
            error_list.append(f"{outer_key} does not have a priority")

        # If priority is in location dict
        else:
            svar_dict[outer_key] = {"priority": outer_value.pop("priority")}

            # For each season name, season value within location dict
            for key, value in outer_value.items():

                svar_dict[outer_key][key] = {}

                # For each seasons setting, season setting value within season
                for inner_key, inner_value in value.items():

                    if inner_key in ["temp_dice", "temp_base", "water_conditions", "wind_dice", "wind_conditions"]:
                        svar_dict[outer_key][key][inner_key] = inner_value

                    else:
                        error_list.append(f"Season {key} in location {outer_key} contains an invalid setting (`{inner_key}`)")
     
    return validate_svar_dict(svar_dict, error_list)


def main(dict_input: dict):

    dict_keys = set(list(dict_input.keys()))

    if not svar_dict := get_svar("weather_settings"):
        svar_dict = {
            "Settings": {
                "water": {},
                "wind": {},
                "temp": {},
                "unit": "imperial",
                "url": {},
                "color": {}
            }
        }

    if len(dict_keys.intersection({"water", "wind", "temp", "unit", "url", "color"})) > 0:
        svar_dict, error_list = edit_general_settings(dict_input, svar_dict)

    elif "priority" in dict_input[list(dict_keys)[0]].keys():
        svar_dict, error_list = edit_location_settings(dict_input, svar_dict)

    else:
        return "embed -title 'You Have Been Sneak Attacked By an Error'"

    
    # Finish writing error statement and then need to construct output for success

</drac2>